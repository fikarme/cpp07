# include <iostream>

// This is a template class, so it can be used with any type.
template<typename T>

class	Array {
	public:
		Array< T >( void ) 									// Default constructor
		{
			this->_size = 0;
			this->_arr = NULL;
			//std::cout << "Default Constructor invoked" << std::endl;
			return ;
		}

		Array< T >( unsigned int n ) 					// Constructor. It is unsigned int because it is the size of the array and size can't be negative value.
		{
			this->_size = n;
			this->_arr = new T[n];	// We must use new operator to create an array as pdf dictates. Because preventive allocation is forbidden. Preventive allocation is allocating memory for an array before we know how many elements we need.
			//std::cout << "Constructor invoked" << std::endl;
			return ;
		}

		Array< T >( const Array & other )			// Copy constructor
		{
			*this = other;
			return ;
		}

		~Array< T >( void )						// Destructor
		{
			if (this->_size > 0)
				delete[] this->_arr;
		};

		Array & operator=(const Array & other)			// Assignation operator
		{
			if (this == &other)			// If the object is assigned to itself, return the object.
				return (*this);
			this->_size = other.getSize();

			// If the array size is valid, create a new array.
			if (this->_size > 0)
				this->_arr = new T[this->_size];

			// Copy the array. One by one. Each element we copy it to the new array.
			for (unsigned int i = 0; i < this->_size; i++)
				this->_arr[i] = other._arr[i];
			return (*this);
		}

		T & operator[](unsigned int index)		// Operator overloading. Its' used to access the elements of the array.
		{
			if (index >= getSize())
				throw std::out_of_range("Out of the range!");
			return (this->_arr[index]);			// Return the element at index.
		}

		unsigned int	getSize(void) const {
			return (this->_size);
		}

	private:
		unsigned int	_size;
		T*				_arr;
};


int main() {

    Array<int> numbers(100);            // Create an array of 100 integers
    int* ptrARR = new int[100];         // Create an array of 100 integers with pointert

    /****************************** Some test shows that array initiliazed with zeros ************************************************************************************************************************/
    // Print numbers array
    // for (int i = 0; i < 100; i++)
    //     std::cout << "numbers[" << i << "]:" << numbers[i] << std::endl;
	/******************************************************************************************************************************************************/


    /******************************************************************************************************************************************************
        By calling srand(time(NULL)) before using rand(),
        you are explicitly setting the seed value for the rand() function based on the current time,
        which makes the sequence of numbers generated by rand() more unpredictable and less likely
        to repeat across different program runs. This is often done to ensure that
        the numbers generated by rand() are truly random and not predictable,
        which is especially useful in scenarios such as simulations, games, and cryptography,
        where unpredictability and randomness are important.
    *****************************************************************************************************************************************************/
    // seed the random number generator. It provides a different sequence of numbers each time the program is run.
    srand(time(NULL));


	// fill the array with random numbers
    for (int i = 0; i < 100; i++)
    {
        const int value = rand();
        numbers[i] = value;
        ptrARR[i] = value;
    }


/**********************************************************/

    //SCOPE 1
    {
        Array<int> tmp(100);    // Create an array of 100 integers

        std::cout<< std::endl << "______________TEST - 1___________________" << std::endl << std::endl;


        /*************************** TRY - CATCH *******************************/
        try
        {
            for (int i = 0; i < 100; i++)       // fill the array with 7
                tmp[i] = 7;
            for (int i = 0; i < 100; i++)    // print the array
                std::cout << "tmp[" << i << "]:" << tmp[i] << std::endl;
            std::cout << std::endl;
        }
        catch(const std::exception& e)
        {
            std::cerr << e.what();
        }
        /*************************** TRY - CATCH *******************************/


        std::cout<< std::endl << "______________TEST - 2___________________" << std::endl << std::endl;



        tmp = numbers;	//copy constructor. From numbers to tmp.
        Array<int> test(tmp);	//assignation operator. from tmp to test.

        // Now we have two arrays with the same values. Let's see if they are the same.



        /*************************** TRY - CATCH *******************************/
        try
        {
			// check if the values are the same
            for (int i = 0; i < 100; i++)
            {
                if (tmp[i] != test[i])
                {
                    std::cerr << "didn't save the same value!!" << std::endl;
                    return 1;
                }
                // Print the values of tmp and test to see if they are the same.
                std::cout << "tmp[" << i << "]:" << tmp[i] << "  -  " << "test[" << i << "]:" << test[i] << std::endl;
            }
        }
        catch(const std::exception& e)
        {
            std::cerr << e.what();
        }
        /*************************** TRY - CATCH *******************************/

        std::cout<< std::endl << "______________TEST - 3___________________" << std::endl << std::endl;

		// Compare those two values to see if they are the same. You will see that they are same.
        std::cout << std::endl << "test[1]:" << test[1] << std::endl;
        std::cout << "tmp[1]:" << tmp[1] << std::endl << std::endl;



        std::cout<< std::endl << "______________TEST - 4___________________" << std::endl << std::endl;

        test[1] = 123456789;

		// Now they should be different.
        std::cout << "test[1]:" << test[1] << std::endl;
        std::cout << "tmp[1]:" << tmp[1] << std::endl << std::endl;
    }

    //SCOPE 2
    {
	// Here we try to access the one element more than range. It should throw an error.
    try
    {
        std::cout<< std::endl << "______________TEST - 5___________________" << std::endl << std::endl;
        numbers[100] = 0;
    }
    catch(const std::exception& e)
    {
        std::cerr << e.what() << std::endl;
        std::cout << "You are trying to access out of range. WTF?" << std::endl;
    }
    }

/**********************************************************/


    delete [] ptrARR; // free the memory if you don't want to have a memory leak :'(
}
